```toml
[advisory]
id = "RUSTSEC-0000-0000"
package = "scanner-rs"
date = "2025-03-27"
informational = "unsound"
categories = ["memory-corruption"]
keywords = ["out-of-bounds read"]
```

```rust
/// Represents a pattern match.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Match<'a> {
	/// Haystack the match was found in.
	pub haystack: &'a [u8],
	/// Offset in the haystack the match was found.
	pub at: u32,
	/// Stored offsets as specified in the pattern.
	pub store: [u32; MAX_STORE],
}

impl<'a> Match<'a> {
	/// Get the pointer to the location that was matched.
	#[inline]
	pub fn ptr(&self) -> *const u8 {
		unsafe { self.haystack.as_ptr().offset(self.at as isize) }
	}
	/// Get a pointer from the store array.
	#[inline]
	pub fn get<T>(&self, idx: usize) -> *const T {
		unsafe { self.haystack.as_ptr().offset(self.store[idx] as isize) as *const T }
	}
}
```

This crate allow users to create out of bound issue by using merely safe api (Ex. `Match.get`).